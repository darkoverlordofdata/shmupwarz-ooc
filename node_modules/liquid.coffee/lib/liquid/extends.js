// Generated by CoffeeScript 1.6.3
(function() {
  var Liquid,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Liquid = require('../liquid');

  Liquid.Extends = (function(_super) {
    var ContentOfVariable, FullToken, IsTag, IsVariable, Syntax;

    __extends(Extends, _super);

    Syntax = RegExp("(" + Liquid.QuotedFragment.source + ")");

    IsTag = RegExp("^" + Liquid.TagStart.source);

    IsVariable = RegExp("^" + Liquid.VariableStart.source);

    FullToken = RegExp("^" + Liquid.TagStart.source + "\\s*(\\w+)\\s*(.*)?" + Liquid.TagEnd.source + "$");

    ContentOfVariable = RegExp("^" + Liquid.VariableStart.source + "(.*)" + Liquid.VariableEnd.source + "$");

    function Extends(tagName, markup, tokens) {
      var $, m, node, _i, _len;
      if (($ = markup.match(Syntax))) {
        this.templateName = $[1];
      } else {
        throw new Liquid.SyntaxError["new"]("Syntax Error in 'extends' - Valid syntax: extends [template]");
      }
      Extends.__super__.constructor.apply(this, arguments);
      m = {};
      for (_i = 0, _len = nodelist.length; _i < _len; _i++) {
        node = nodelist[_i];
        if (node instanceof Liquid.Tags.Block) {
          m[node.name] = node;
        }
      }
      this.blocks = m;
    }

    Extends.prototype.parse = function(tokens) {
      return parseAll(tokens);
    };

    Extends.prototype.render = function(context) {
      var block, name, parentBlocks, pb, template, _ref;
      template = this.loadTemplate(context);
      parentBlocks = this.findBlocks(template.root);
      _ref = this.blocks;
      for (name in _ref) {
        block = _ref[name];
        if (pb = parentBlocks[name]) {
          pb.parent = block.parent;
          pb.addParent(pb.nodelist);
          pb.nodelist = block.nodelist;
        } else {
          if (isExtending(template)) {
            template.root.nodelist.push(block);
          }
        }
      }
      return template.render(context);
    };

    Extends.prototype.parseAll = function(tokens) {
      var $, tag, token, _results;
      this.nodelist || (this.nodelist = []);
      this.nodelist.clear;
      _results = [];
      while ((token = tokens.shift()) != null) {
        if (IsTag.test(token)) {
          if (($ = token.match(FullToken))) {
            if (tag = Liquid.Template.Tags[$[1]]) {
              _results.push(this.nodelist.push(new tag($[1], $[2], tokens)));
            } else {
              _results.push(this.unknownTag($[1], $[2], tokens));
            }
          } else {
            throw new Liquid.SyntaxError("Tag '" + token + "' was not properly terminated with regexp: " + TagEnd.inspect + " ");
          }
        } else if (IsVariable.test(token)) {
          _results.push(this.nodelist.push(this.createVariable(token)));
        } else if (token === '') {

        } else {
          _results.push(this.nodelist.push(token));
        }
      }
      return _results;
    };

    Extends.prototype.loadTemplate = function(context) {
      var source;
      source = Liquid.Template.fileSystem.readTemplateFile(context.get(this.template_name));
      return Liquid.Template.parse(source);
    };

    Extends.prototype.findBlocks = function(node, blocks) {
      var b, _i, _len, _ref;
      if (blocks == null) {
        blocks = {};
      }
      if (node.nodelist != null) {
        b = blocks;
        _ref = node.nodelist;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          if (node instanceof Liquid.Tags.Block) {
            b[node.name] = node;
          } else {
            this.findBlocks(node, b);
          }
          b;
        }
      }
      return blocks;
    };

    Extends.prototype.isExtending = function(template) {
      var node, _i, _len, _ref;
      _ref = template.root.nodelist;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node instanceof Extends) {
          return true;
        }
      }
      return false;
    };

    return Extends;

  })(Liquid.Block);

}).call(this);
