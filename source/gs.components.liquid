/**
 * Entitas Generated Components and Extensions for {{ namespace }}
 *
 * do not edit this file
 */
[indent=4]
namespace {{ namespace }}

    const POOL_SIZE : int = {{ alloc.components }}

    /**
    * Component extensions
    */
    const components: array of string = {
{% for component in components %}        "{{ component.key }}Component",
{% endfor %}        "ComponentsCount"
    }

    enum Component
{% for component in components %}        {{ component.key }}
{% endfor %}        ComponentsCount


{% for component in components %}
    class {{ component.key }}Component : Object implements Entitas.IComponent 
{% if component.value == false %}        active : bool = true
{% else %}{% for field in component.value %}        {{ field | property }} : {{ field | fieldType }} 
{% endfor %}{% endif %}{% endfor %}


    /**
    * Entity extensions
    */
    class Entity : Entitas.Entity

        construct(componentsEnum : array of string, totalComponents : int=32)
            super(componentsEnum, totalComponents)
{% for component in components %}
        /** Entity: {{ component.key }} methods*/
{% if component.value == false %}
        /** @type boolean */
        prop is{{ component.key }} : bool
            get
                return hasComponent(Component.{{ component.key }})
            set
                if value
                    addComponent(Component.{{ component.key }}, _{{ component.key | camel }}Component)
                else
                    removeComponent(Component.{{ component.key }})
                
        /**
         * @param value boolean
         * @return entitas.Entity
         */
        def set{{ component.key }}(value : bool) : Entity
            is{{ component.key }} = value
            return this

{% else %}
        /** @type {{ component.key }} */
        prop {{ component.key | camel }} : {{ component.key }}Component
            get
                return ({{ component.key }}Component)getComponent(Component.{{ component.key }})

        /** @type boolean */
        prop has{{ component.key }} : bool
            get
                return hasComponent(Component.{{ component.key }})
 
        def clear{{ component.key }}ComponentPool()
            _{{ component.key | camel }}ComponentPool.clear()

        /**{% for field in component.value %}
         * @param {{ field | property }} {{ field | fieldType }}{% endfor %}
         * @return entitas.Entity
         */
        def add{{ component.key }}({{ component.value }}) : Entity
            var c = _{{ component.key | camel }}ComponentPool.length > 0 ? _{{ component.key | camel }}ComponentPool.pop_head() : new {{ component.key }}Component()
            {% for field in component.value %}c.{{ field | property }} = {{ field | property | camel }}
            {% endfor %}addComponent(Component.{{ component.key }}, c)
            return this

        /**{% for field in component.value %}
         * @param {{ field | property }} {{ field | fieldType }}{% endfor %}
         * @return entitas.Entity
         */
        def replace{{ component.key }}({{ component.value }}) : Entity
            var previousComponent = has{{ component.key }} ? this.{{ component.key | camel }} : null
            var c = _{{ component.key | camel }}ComponentPool.length>0? _{{ component.key | camel }}ComponentPool.pop_head() : new {{ component.key }}Component()
            {% for field in component.value %}c.{{ field | property }} = {{ field | property | camel }}
            {% endfor %}replaceComponent(Component.{{ component.key }}, c) 
            if previousComponent != null
                _{{ component.key | camel }}ComponentPool.push_head(previousComponent)
            return this

        /**
         * @returns entitas.Entity
         */
        def remove{{ component.key }}() : Entity
            var c = {{ component.key | camel }}
            removeComponent(Component.{{ component.key }}) 
            _{{ component.key | camel }}ComponentPool.push_head(c)
            return this

{% endif %}{% endfor %}
{% for component in components %}{% if component.value == false %}
    /** @type {{ component.key }} */
    _{{ component.key | camel }}Component : {{ component.key }}Component
{% else %}        /** @type entitas.utils.GLib.Queue<{{ component.key }}> */
    _{{ component.key | camel }}ComponentPool : GLib.Queue of {{ component.key }}Component
{% endif %}{% endfor %}

    def initPools()
        /* Preallocate component pools*/
{% for component in components %}{% if component.value == false %}
        _{{ component.key | camel }}Component = new {{ component.key }}Component()
{% else %}        _{{ component.key | camel }}ComponentPool = new GLib.Queue of {{ component.key }}Component
        for var i=1 to POOL_SIZE
            _{{ component.key | camel }}ComponentPool.push_head(new {{ component.key }}Component())
{% endif %}{% endfor %}


    /**
     * MatchAllOf
     * @param world where the pools are
     * @param components to match
     * @return Iterable for entities in the group
     *
     *  usage:
     *      _group = MatchAllOf(_world, {Component.ScaleTween, Component.Resource})
     */
    def MatchAllOf(world: Entitas.World, selection:array of int): Match
        return new Match(world.getGroup(Entitas.Matcher.AllOf(selection)))

    /**
     * MatchAnyOf
     * @param world where the pools are
     * @param components to match
     * @return Iterable for entities in the group
     *
     *  usage:
     *      _group = MatchAnyOf(_world, {Component.ScaleTween, Component.Resource})
     */
    def MatchAnyOf(world: Entitas.World, selection:array of int): Match
        return new Match(world.getGroup(Entitas.Matcher.AnyOf(selection)))

    class abstract IterableOfEntity: Object implements Gee.Traversable of (Entity), Gee.Iterable of (Entity)
        prop abstract readonly element_type: Type
        def abstract iterator(): Gee.Iterator of Entity
        def @foreach(f: Gee.ForallFunc of Entity): bool
            for var i in self
                if not f(i)
                    return false
            return true
    /**
    * Match iterator
    *
    *  Unboxing Iterator
    *
    *  Iterate over a Entity.Group, 
    *  Casts each item to {{ namespace }}.Entity 
    *
    */
    class Match: IterableOfEntity
        construct(entities: Entitas.Group)
            _entities = entities
        
        prop override readonly element_type: Type
            get
                return typeof(Entity)
            
        def override iterator(): Gee.Iterator of Entity
            return new EntityIterator(_entities.getEntities())

        _entities: Entitas.Group



    class EntityIterator: Object implements Gee.Traversable of (Entity), Gee.Iterator of (Entity)
        construct(entities: array of Entitas.IEntity)
            _entities = entities
            _length = entities.length

        prop readonly valid: bool = true
        prop readonly read_only: bool = true

        def next(): bool
            return ++_index < _length
        
        def new @get(): Entity
            return (Entity)_entities[_index]
        
        def has_next(): bool
            return _index < _length - 1
        
        def remove()
            pass // readonly

        def @foreach(f: Gee.ForallFunc of Entity): bool
            _index--
            while next()
                if not f(@get())
                    return false
            return true
        
        _entities: array of Entitas.IEntity
        _index: int = -1
        _length: uint

